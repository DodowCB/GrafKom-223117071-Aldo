<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Raytracing Demo (Canvas 2D) - Multiple Spheres from JSON</title>
    <style>
        /* Styling untuk container canvas dan info */
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center; /* Tengahkan container secara horizontal */
            align-items: center; /* Tengahkan container secara vertikal */
            min-height: 100vh; /* Pastikan body minimal setinggi viewport */
            background-color: #333; /* Warna latar belakang */
            flex-direction: column; /* Tumpuk item secara vertikal */
            font-family: sans-serif; /* Font lebih mudah dibaca */
            color: #eee; /* Warna teks untuk info */
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Pusatkan item di dalam container */
        }
        canvas {
            border: 1px solid #ccc; /* Border agar canvas terlihat */
            display: block; /* Penting untuk menghilangkan margin bawah bawaan inline/inline-block */
        }
        #objectInfo {
            margin-top: 10px; /* Jarak antara canvas dan info */
            padding: 10px;
            background-color: #555;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: left; /* Info bisa multi-baris, biarkan kiri */
            max-width: 500px; /* Batasi lebar agar sesuai canvas */
            width: 100%; /* Ambil lebar maksimum dari parent container */
            box-sizing: border-box; /* Include padding/border dalam width */
        }
        #objectInfo strong {
            display: block; /* Buat judul info di baris baru */
            margin-bottom: 5px;
        }
        #objectInfo div {
            margin-bottom: 8px; /* Jarak antar info objek */
            padding-bottom: 8px;
            border-bottom: 1px dashed #777; /* Pemisah antar objek */
        }
         #objectInfo div:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none; /* Hapus border bawah untuk item terakhir */
        }
    </style>
    <!-- Sertakan gl-matrix untuk operasi vektor/matriks. -->
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
</head>
<body>

    <!-- Container untuk canvas dan info agar mudah ditata -->
    <div id="container">
        <!-- Canvas untuk rendering -->
        <canvas id="raytraceCanvas" width="500" height="500"></canvas>

        <!-- Area untuk menampilkan informasi objek -->
        <div id="objectInfo">
            <strong>Informasi Objek Scene:</strong><br>Memuat...
        </div>
    </div>


    <script>
        // Gunakan namespace glMatrix untuk kemudahan akses
        const vec3 = glMatrix.vec3;

        // --- Definisi Objek di Scene ---

        // Class dasar untuk objek yang bisa di-raytrace
        class SceneObject {
            constructor(color) {
                this.color = color; // [r, g, b] format
            }

            // Metode ini harus diimplementasikan oleh turunan (misal: Sphere)
            // Mengembalikan t value (jarak parameter sepanjang ray) dari perpotongan terdekat,
            // atau -1 jika tidak ada perpotongan positif (di depan ray origin).
            intersect(rayOrigin, rayDirection) {
                return -1; // Default: tidak ada perpotongan
            }
        }

        // Objek Bola (Sphere)
        class Sphere extends SceneObject {
            constructor(center, radius, color) {
                super(color);
                this.center = vec3.fromValues(...center); // Gunakan vec3 dari gl-matrix
                this.radius = radius;
            }

            // Implementasi perpotongan ray-sphere (sama seperti sebelumnya)
            intersect(rayOrigin, rayDirection) {
                const L = vec3.create();
                vec3.subtract(L, this.center, rayOrigin);

                const a = vec3.dot(rayDirection, rayDirection);
                const b = -2 * vec3.dot(rayDirection, L);
                const c = vec3.dot(L, L) - this.radius * this.radius;

                let discriminant = b * b - 4 * a * c;

                if (discriminant < 0) {
                    return -1;
                }

                let t0 = (-b - Math.sqrt(discriminant)) / (2 * a);
                let t1 = (-b + Math.sqrt(discriminant)) / (2 * a);

                const epsilon = 0.0001;

                if (t0 > epsilon) {
                    return t0;
                }

                if (t1 > epsilon) {
                    return t1;
                }

                return -1;
            }
        }

        // --- Konfigurasi Scene dalam bentuk JSON String ---
        const jsonSceneConfig = `
        [
          {
            "type": "sphere",
            "center": [0, 0, 0],
            "radius": 0.3,
            "color": [255, 0, 0]
          },
          {
            "type": "sphere",
            "center": [0.5, -0.4, -2.0],
            "radius": 0.5,
            "color": [0, 255, 0]
          }
        ]
        `;

        // --- Fungsi untuk Membuat Objek Scene dari JSON ---
        function createSceneObjects(jsonConfigString) {
            let config;
            try {
                config = JSON.parse(jsonConfigString);
            } catch (error) {
                console.error("Gagal mengurai JSON konfigurasi scene:", error);
                return []; // Kembalikan array kosong jika parsing gagal
            }

            const objects = [];

            for (const item of config) {
                if (item.type === "sphere") {
                    // Validasi minimal: pastikan properti yang dibutuhkan ada
                    if (item.center && Array.isArray(item.center) && item.center.length === 3 &&
                        typeof item.radius === 'number' && item.radius > 0 &&
                        item.color && Array.isArray(item.color) && item.color.length === 3) {
                         objects.push(new Sphere(item.center, item.radius, item.color));
                    } else {
                        console.warn("Melewati objek sphere tidak valid:", item);
                    }
                }
                // Tambahkan tipe objek lain di sini jika diperlukan (misal: plane)
                // else if (item.type === "plane") { ... }
                 else {
                    console.warn("Tipe objek tidak dikenal:", item.type);
                }
            }

            return objects;
        }

        // Buat objek scene berdasarkan konfigurasi JSON
        const sceneObjects = createSceneObjects(jsonSceneConfig);


        // --- Pengaturan Kamera ---
        const cameraOrigin = vec3.fromValues(0, 0, 5); // Posisi kamera tetap
        const screenPlaneWidth = 2.0; // Ukuran bidang layar tetap
        const screenPlaneHeight = 2.0; // Ukuran bidang layar tetap
        const screenPlaneZ = 0.0; // Jarak bidang layar tetap

        // Warna latar belakang jika ray tidak mengenai objek apapun
        const backgroundColor = [50, 50, 50]; // Abu-abu gelap

        // --- Fungsi Raytracing Utama ---
        function raytrace() {
            const canvas = document.getElementById('raytraceCanvas');
            if (!canvas) {
                console.error("Elemen canvas tidak ditemukan!");
                return;
            }
            const ctx = canvas.getContext('2d');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const imageData = ctx.createImageData(canvasWidth, canvasHeight);
            const data = imageData.data;

            for (let y = 0; y < canvasHeight; y++) {
                for (let x = 0; x < canvasWidth; x++) {

                    const normX = x / canvasWidth;
                    const normY = y / canvasHeight;

                    const screenX = normX * screenPlaneWidth - screenPlaneWidth / 2;
                    const screenY = screenPlaneHeight / 2 - normY * screenPlaneHeight; // Inverted Y
                    const screenPoint = vec3.fromValues(screenX, screenY, screenPlaneZ);

                    const rayOrigin = cameraOrigin;
                    const rayDirection = vec3.create();
                    vec3.subtract(rayDirection, screenPoint, rayOrigin);
                    vec3.normalize(rayDirection, rayDirection);

                    let closestT = Infinity;
                    let hitObject = null;

                    // Loop melalui setiap objek di sceneObjects (sekarang diisi dari JSON)
                    for (const object of sceneObjects) {
                        const t = object.intersect(rayOrigin, rayDirection);
                        if (t > 0 && t < closestT) {
                            closestT = t;
                            hitObject = object;
                        }
                    }

                    let pixelColor;
                    if (hitObject) {
                        pixelColor = hitObject.color;
                        // Di sini Anda akan menambahkan logika pencahayaan jika diperlukan di masa mendatang
                        // const hitPoint = vec3.scaleAndAdd(vec3.create(), rayOrigin, rayDirection, closestT);
                        // const surfaceNormal = hitObject.getNormalAtPoint(hitPoint); // Perlu implementasi metode ini di objek
                        // ... hitung pencahayaan ...
                    } else {
                        pixelColor = backgroundColor;
                    }

                    const pixelIndex = (y * canvasWidth + x) * 4;
                    data[pixelIndex + 0] = pixelColor[0];
                    data[pixelIndex + 1] = pixelColor[1];
                    data[pixelIndex + 2] = pixelColor[2];
                    data[pixelIndex + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            console.log(`Raytracing selesai. Menggambar ${sceneObjects.length} objek.`);
        }

        // --- Fungsi untuk Menampilkan Info Objek ---
        function displayObjectInfo() {
            const infoDiv = document.getElementById('objectInfo');
            if (!infoDiv) {
                console.error("Elemen infoDiv tidak ditemukan!");
                return;
            }

            // Kosongkan konten sebelumnya
            infoDiv.innerHTML = '<strong>Informasi Objek Scene:</strong>';

            if (sceneObjects.length === 0) {
                 infoDiv.innerHTML += '<br>Tidak ada objek dalam scene.';
                 return;
            }

            // Iterasi melalui SEMUA objek di sceneObjects
            sceneObjects.forEach((object, index) => {
                const objectEntryDiv = document.createElement('div');
                let infoText = `Objek ${index + 1}: `; // Beri nomor objek

                if (object instanceof Sphere) {
                    const centerX = object.center[0].toFixed(2);
                    const centerY = object.center[1].toFixed(2);
                    const centerZ = object.center[2].toFixed(2);
                    const radius = object.radius.toFixed(2);
                    const color = object.color.join(', ');

                    infoText += `Bola (Sphere)<br>
                                Posisi (Center): (${centerX}, ${centerY}, ${centerZ})<br>
                                Jari-jari (Radius): ${radius}<br>
                                Warna (RGB): (${color})`;
                } else {
                    // Tangani tipe objek lain jika ada
                    infoText += `Tipe tidak dikenal`;
                }
                 objectEntryDiv.innerHTML = infoText;
                 infoDiv.appendChild(objectEntryDiv);
            });
        }


        // Jalankan fungsi raytrace dan displayObjectInfo saat halaman selesai dimuat
        window.onload = () => {
            // sceneObjects sudah dibuat saat script dimuat
            raytrace();
            displayObjectInfo(); // Panggil setelah objek sceneObjects didefinisikan
        };

    </script>

</body>
</html>